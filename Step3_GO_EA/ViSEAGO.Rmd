---
title: "GO Enrichment Analysis"
author: "Andrea Nieto-Aliseda Sutton"
date: "4/14/2020"
output: 
  html_document:
    keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ViSEAGO)
```

### __Summary__  

A GO Enrichment Analysis sets out to identify GO terms that are more related to a subset of genes than expected. The expectation of how frequent a GO term should appear is defined by the __universe__, being a sort of a background model.  

The list of genes we are going to use as query has been obtained by the integration between B-ALL associated DMPs falling at enhancer regions as defined by the ensembl regulatory build and PCHi-C data (for now we are using Naive B).  
The genes therefore are those which are possibly being dysregulated by long-range regulatory elements (enhancers). 

<br>  
  
To start, the subset of genes has to be read in. 
<br>  
```{r, echo=FALSE}
selection <- read.table("/media/andrea/SAMSUNG/IJC/Aim3/WORKFLOW-31-03/genes_all.txt", stringsAsFactors = F)
selection <- selection$V1
```
The subset of genes we want to study consist of __```r length(selection)``` genes__
<br>  
```{r, echo=FALSE}

capt <- read.table("/media/andrea/SAMSUNG/IJC/superquery/realfinal_superquery.txt", header = T, stringsAsFactors = F)
background <- unique(capt$ensembl_gene_id[!is.na(capt$ensembl_gene_id)]) 

```
__```r length(background)```__ genes will be used as background  
  
<br>  
The GO Annotation database has to be retreived. ViSEAGO package has to option of using previous releases (GRCh37.p13). We are going to be using the Ensembl database, as out genes are defined by ensembl IDs.  

A small explanation of why this package is better that clusterprofiler (for example) is summarised in the table found at the following link: [link](https://biodatamining.biomedcentral.com/articles/10.1186/s13040-019-0204-1/tables/1)  
<br>  

```{r, echo=FALSE}

Ensembl <- ViSEAGO::Ensembl2GO(host = "grch37.ensembl.org")
myGENE2GO <- ViSEAGO::annotate("hsapiens_gene_ensembl", Ensembl)

```

## Functional Enrichment Analysis (BP)  

Using the __classic__ algorithm, which tests each GO term independently, and __fisher__ as a statistical test, which is based on gene counts, the enrichment analysis is performed (taking into account the background we have predefined)   
```{r include=FALSE}
BP <- ViSEAGO::create_topGOdata(geneSel=selection, allGenes=background, gene2GO=myGENE2GO, ont="BP", nodeSize=5)
classic <- topGO::runTest(BP, algorithm ="classic", statistic = "fisher")


BP_sResults<-ViSEAGO::merge_enrich_terms(
  Input=list(
    classic=c("BP","classic")
  )
)
```

```{r, echo=FALSE}
ViSEAGO::show_table(BP_sResults)
```
>The p-values have not been corrected for multiple testing, as we are performing an exploratory analysis and in many cases adjusted p-values may be misleading!  

<br>  


## Semantic Similarity Analysis  

Semantic Similarity is defined as how similar to GOterms are based on their meanings. Therefore, SS are used to group together enriched GO terms according to their annotation and their topological position in the GO graph.  

I am calculating the "distance" between to terms using the __Wang__ method, a gragh-based method which mantains the topology of the GO graph throughout the analysis.  
There are also other types of methods based solely on Information Content...  
```{r plot1, echo=FALSE}
myGOs<-ViSEAGO::build_GO_SS(
  gene2GO=myGENE2GO,
  enrich_GO_terms=BP_sResults
)

myGOs<-ViSEAGO::compute_SS_distances(
  myGOs,
  distance="Wang"
)
```

```{r, echo=FALSE}
ViSEAGO::MDSplot(myGOs)
```

```{r, include=FALSE}

Wang_clusters_wardD2<-ViSEAGO::GOterms_heatmap(
  myGOs,
  showIC=TRUE,
  showGOlabels=TRUE,
  GO.tree=list(
    tree=list(
      distance="Wang",
      aggreg.method="ward.D2"
    ),
    cut=list(
      dynamic=list(
        pamStage=TRUE,
        pamRespectsDendro=TRUE,
        deepSplit=2,
        minClusterSize =2
      )
    )
  ),
  samples.tree=NULL
)

```

```{r, echo=FALSE}
ViSEAGO::show_heatmap(
  Wang_clusters_wardD2,
  "GOterms"
)



# display colored MDSplot
ViSEAGO::MDSplot(
  Wang_clusters_wardD2,
  "GOterms"
)
```

## Clustering of enriched GO Terms  

Another step that can be taken is clustering of GO terms. Using this information makes it easier to understand the data at hand.  

Distances between GO terms are calculated using the __Best Combination Approach (BMA)__ calculates the maximum similarity over all pairs of GO terms between two GO term sets, averaged with its reciprocal to obtain symmetric similarity.  

```{r, include=FALSE}

Wang_clusters_wardD2<-ViSEAGO::compute_SS_distances(
  Wang_clusters_wardD2,
  distance=c("max", "avg","rcmax", "BMA")
)
```

```{r, echo=FALSE}
ViSEAGO::MDSplot(
  Wang_clusters_wardD2,
  "GOclusters"
)

```

```{r, include=FALSE}
Wang_clusters_wardD2<-ViSEAGO::GOclusters_heatmap(
  Wang_clusters_wardD2,
  tree=list(
    distance="BMA",
    aggreg.method="ward.D2"
  )
)
```

```{r echo=FALSE}
ViSEAGO::show_heatmap(
  Wang_clusters_wardD2,
  "GOclusters"
)
```

With this clustering approach, a total of 26 clusters are identified.  
The names of the clusters are the first common GO term ancestor of the cluster. 


## Exploratory Analysis of 26 clusters  

